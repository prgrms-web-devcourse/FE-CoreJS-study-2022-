# this

다른 대부분의 객체지향 언어에서 `this`는 클래스로 생성한 인스턴스 객체를 의미한다.
그러나 자바스크립트에서의 `this`는 어디서든 사용할 수 있다. 상황에 따라 `this`가 바라보는 대상이 달라진다.

함수와 객체(메서드)의 구분이 느슨한 자바스크립트에서 `this`는 실질적으로 이 둘을 구분하는 거의 유일한 기능이다.

## 상황에 따라 달라지는 this

- 자바스크립트에서 `this`는 기본적으로 실행 컨텍스트가 생성될 때 함께 결정된다.
- 실행 컨텍스트는 함수를 호출할 때 생성되므로, 바꿔 말하면 `this`는 **함수가 호출될 때 결정된다**고 할 수 있다.
- **함수를 어떤 방식으로 호출하느냐에 따라 값이 달라지는 것이다.**

## 구체적으로 호출하는 방식에 따라 this가 어떻게 다른지를 정리를 하자면

1. 전역 공간에서
2. 함수 호출시
3. 메서드 호출시
4. callback 호출시
5. 생성자 함수 호출시

<br>

---

## 전역 공간에서의 this

- 전역 공간에서 `this`는 전역 객체를 가리킨다.
- 전역 객체는 자바스크립트 런타임 환경에 따라 다른 이름과 정보를 가지고 있다.
- 브라우저 환경에서 전역객체는 `window`이고 **Node.js** 환경에서는 `global`이다.

<br>

---

## 함수에서 호출시

함수에서 호출시에도 전역 객체를 가리킨다.

```javascript
function a() {
  console.log(this);
}
a();
function b() {
  function c() {
    console.log(this);
  }
  c();
}
b();
```

내부 함수인 c에서도 전역 객체를 가리키는데 이것은 버그라 말하는 사람도 있고 자바스크립트 고유의 특성이라고 하는 의견도 있는데 이것은 ES6에서 **arrow function**로
문제점이 해소 되지만 ES5에서는 언제나 전역 객체를 가리킨다.

```javascript
var d = {
  e: function () {
    function f() {
      console.log(this);
    }
    f();
  },
};
d.e();
```

메서드로 호출 하였을 때도 내부 함수를 보면 무조건 전역 객체를 가리키고 있다.

<br>

---

## 메서드 호출시

메서드를 호출한 주체가 누구냐에 따라서 this가 가르키는 객체가 달라진다.

```javascript
var a = {
  b: function () {
    console.log(this);
  },
};
a.b();
```

- `this`에는 호출한 주체에 대한 정보가 담긴다.
- 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명(프로퍼티명) 앞의 객체이다.
- 점 표기법의 경우 마지막 점 앞에 명시된 객체가 곧 `this`가 되는 것이다.

<br>

### 대괄호 표기법일때는?

```javascript
obj.func();
obj["func"]();

person.info.getName();
person.info["getName"]();
person["info"].getName();
person["info"]["getName"]();
```

### 메서드 내부함수에서의 우회법

```javascript
var a = 10;
var obj = {
  a: 20,
  b: function () {
    console.log(this.a);

    function c() {
      console.log(this.a);
    }
    c();
  },
};
obj.b();
```

내부 함수 c 앞에 this가 없어서 전역 객체를 가르키고 있다.
그러면 전역 객체의 a 프로퍼티를 찾아라 라는 명령이 되는데 이때 값은 10이 나온다.
이 뜻은 전역 객체의 프로퍼티 a를 달라고 했더니, 전역 변수 a를 주는 것이다.
전역 객체는 전역 객체고 전역 변수는 전역 변수로 서로 별개의 개념이여야 될거 같은데
실제로는 전역 변수가 곧 전역 객체의 프로퍼티로 동작을 한다.

여기서 this가 obj를 가르키게 하려면 call,apply같은 명시적인 this 바인딩 명령을 쓰지 않고는 this 자체를 직접 다른 값으로 덮어 씌울 수는 없다.

결국에 다른 변수를 쓰게 하는 방법이 있는데 이것은 스코프 체인을 이용하여 적용 할 수 있다.

```javascript
var a = 10;
var obj = {
  a: 20,
  b: function () {
    var self = this;
    console.log(this.a);

    function c() {
      console.log(self.a);
    }
    c();
  },
};
obj.b();
```

ES6에서는 this를 바인딩 하지 않는 **arrow function**이라는게 등장 하면서 쓸 이유가 사실상 없어 졌다.

```javascript
var a = 10;
var obj = {
  a: 20,
  b: function() {
    console.log(this.a);

    function c = () => {
      console.log(this.a);
    }
    c();
  }
}
obj.b();
```

## 콜백 함수 호출 시

기본적으로는 함수 내부에서와 동일하다.

- 함수 A의 제어권을 다른 함수(또는 메서드) B에게 넘겨주는 경우 함수 A를 콜백 함수라 한다.
- 함수 A는 함수 B의 내부 로직에 따라 실행되며, this 역시 함수 B 내부 로직에서 정한 규칙에 따라 값이 결정된다.
- `this`가 전역객체를 참조하지만, 제어권을 받은 함수에서 콜백 함수에 별도로 this가 될 대상을 지정한 경우에는 그 대상을 참조하게 된다.
- 콜백 함수 내부에서의 this는 전역객체를 참조한다.
- `addEventListener` 메서드는 콜백 함수를 호출할 때 자신의 `this`를 상속하도록 정의돼 있다.
  - 메서드명의 `점(.)` 앞부분이 곧 `this`가 되는 것이다.

<br>

- 콜백 함수의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 할지를 결정하며, 특별히 정의하지 않은 경우에는 기본적으로 함수와 마찬가지로 전역객체를 바라본다.

간단히 정리 하자면

1. 기본적으로 함수의 this와 같다.
2. 제어권을 가진 함수가 콜백의 this를 지정해둔 경우도 있다.
3. 이 경우에도 개발자가 this를 바인딩해서 콜백을 넘기면 그에 따른다.

## 명시적으로 this를 바인딩하는 방법

- this에 별도의 대상을 바인딩하는 방법

<br>

### call 메서드

- call 메서드는 메서드의 호출 주체인 함수를 즉시 실행하도록 하는 명령이다.
- call 메서드의 첫 번째 인자를 this로 바인딩하고, 이후의 인자들을 호출할 함수의 매개변수로 한다.
- 함수를 그냥 실행하면 this는 전역객체를 참조하지만 **call 메서드를 이용하면 임의의 객체를 this로 지정할 수 있다.**
- 메서드에 대해서도 마찬가지로 **객체의 메서드를 그냥 호출하면 this는 객체를 참조하지만 call 메서드를 이용하면 임의의 객체를 this로 지정**할 수 있다.

<br>

### apply 메서드

- apply 메서드는 call 메서드와 기능적으로 완전히 동일하다
- apply 메서드는 두 번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다는 점에서만 차이가 있다.

<br>

### bind 메서드

- 즉시 호출하지는 않고 넘겨받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드이다.
- `bind` 메서드는 함수에 `this`를 미리 적용하는 것과 부분 적용 함수를 구현하는 두 가지 목적을 모두 지닌다.

<br>

## 생성자 함수로 호출 시

생성자 함수로 호출했을 시 즉 new 연산자를 사용했을 때 생성자 함수 내용을 바탕으로 인스턴스 객체를 만드는 명령이다.
이때는 새로 만들 인스턴스 객체 그 자체가 곧 this가 된다.

```javascript
function Person(n, a) {
  this.name = n;
  this.age = a;
}
var tae = Person("태욱", 10);
console.log(window.name, window.age);
```

일반적으로 new 연산자 없이 그냥 Person 함수를 호출할 경우에는
tae에는 아무것도 담기지 않고 함수로서 호출한 것이기 때문에
이때의 this는 전역 객체를 가리키게 된다.
그러니까 전역 객체의 name 프로퍼티와 age 프로퍼티에 값이 할당 되어서 `태욱 10`이 나온다.

```javascript
function Person(n, a) {
  this.name = n;
  this.age = a;
}
var tae = new Person("태욱", 10);
console.log(window.name, window.age);
```

그런데 new를 넣은채로 호출을 하면 생성자 함수로서 호출한 것이므로 즉 새로 생성될 Person의 인스턴스 객체 자신이 this가 되므로 객체가 새로 만들어 지면서 그 객체 안에
name, age 프로퍼티가 생성 되면서 그 객체가 다시 tae로 들어간다.

<br>

다시 한번 정리를 해보자면

- 전역 공간에서의 this는 전역 객체를 가리킨다.
- 함수에서도 전역 객체를 가리킨다.
- 메서드 호출 시에는 메서드 호출 주체가 this가 된다.
- callback 호출시에는 기본적으로는 함수내부에서와 동일하지만 콜백함수를 어떻게 처리하는지에 따라 this 는 얼마든지 달라지고 그런 경우에도 bind 명령등을 통해 사용자가 직접 this를 명시할 수 있다.
- 생성자 함수 호출시에는 인스턴스가 곧 this다.

## 퀴즈

```javascript
function a(x, y, z) {
  console.log(this, x, y, z);
}
var b = {
  bb: "bbb",
};

a.call(b, 1, 2, 3);

a.apply(b, [1, 2, 3]);

var c = a.bind(b);
c(1, 2, 3);

var d = a.bind(b, 1, 2);
d(3);
```

call, apply, c, d 의 각각 호출 결과는?