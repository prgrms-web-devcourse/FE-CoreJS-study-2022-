## 프로토타입

자바스크립트는 프로토타입 기반 언어이다.
클래스 기반 언어에서는 상속을 사용하지만 프로토타입 기반 언어에서는 어떤 객체를 원형(prototype)으로 삼고 이를 복제함으로써 상속과 비슷한 효과를 얻는다.
ES6에 class 키워드가 추가되었지만, 그렇다고 자바스크립트가 클래스 기반언어가 된 것은 아니다.

### constructor, prototype, instance

```jsx
var instance = new Constructor();
```

![https://blog.kakaocdn.net/dn/BLlzA/btrnku0buwy/dqab9KSbiv9hsJ3bnRofU1/img.jpg](https://blog.kakaocdn.net/dn/BLlzA/btrnku0buwy/dqab9KSbiv9hsJ3bnRofU1/img.jpg)

1. 어떤 생성자 함수*Constructor* 를 new 연산자와 함께 호출하면
2. Constructor에서 정의된 내용을 바탕으로 새로운 인스턴스*instance* 가 생성된다.
3. 이때 instance에는 **proto**라는 프로퍼티가 자동으로 부여(생략 가능)되는데,
4. 이 프로퍼티는 Constructor의 prototype이라는 프로퍼티를 참조한다.

- prototype은 객체 (**proto** 또한 객체)
- prototype 객체 내부에는 인스턴스가 사용할 메서드를 저장
- 인스턴스에서도 숨겨진 프로퍼티인 **proto**를 통해 메서드들에 접근할 수 있다.
- 실무에서는 가급적 **proto**를 사용하지 않고, getPrototypeOf() / Object.create() 등을 이용하는 것을 권장

**① constructor, prototype, instance**

```jsx
var Person = function (name) {
  this._name = name;
};
Person.prototype.getName = function () {
  return this._name;
};

var wook = new Person("Wook");

Person.prototype === wook.__proto__; // true
```

Person의 인스턴스는 `__proto__`
프로퍼티를 통해 getName을 호출할 수 있음

- 인스턴스의 `__proto__`
  가 Constructor의 prototype 프로퍼티를 참조해 둘은 같은 객체를 바라보기 때문

**② consturctor 프로퍼티**

생성자 함수의 프로퍼티인 prototype 객체 내부에는 constructor라는 프로퍼티가 있다. 인스턴스의 **proto** 객체 내부에도 마찬가지이다. 이 프로퍼티는 단어 그대로 원래 생성자 함수(자기 자신)를 참조한다. 자신을 참고하는 프로퍼티를 뭐하러 가질까 싶지만 이 역시 인스턴스로부터 그 원형이 무엇인지 알 수 있는 수단이 되는 필요한 정보이다.

```jsx
var arr = [1, 2];
Array.prototype.constructor === Array; //true
arr.__proto__.constructor === Array; //true
arr.constructor === Array; //true

var arr2 = new arr.constructor(3, 4);
console.log(arr2); // [3, 4]
```

## 프로토타입 체인

### **① 메소드 오버라이드**

prototype 객체를 참조하는 **proto**를 생략할 수 있기 때문에, 인스턴스는 prototype에 정의된 프로퍼티나 메서드를 자신의 것처럼 사용할 수 있는 것처럼 보인다.

```jsx
const Person = function (name) {
  this.name = name;
};
Person.prototype.getName = function () {
  return this.name;
};

const IU = new Person("이지은");
IU.getName = function () {
  return "IU는 " + this.name + "이다.";
};
console.log(IU.getName()); // 'IU는 이지은이다.'
console.log(IU.__proto__.getName.apply(IU)); // '이지은'
```

IU 인스턴스에 있는 메서드가 호출된다. Person prototype 객체에 등록된 getName 메서드와 동일한 함 수 명이기 때문에 원본이 있는 그 상태에서 다른 대상을 얹은 것이다.

오버라이딩 되지 않고, prototype에 등록된 메서드가 동자가헤 하려면, IU 인스턴스에 있는 **proto**에다가 IU 인스턴스를 바라볼 수 있게 등록하면 된다. call, apply 메서드로 바인딩을 해주면 된다. 원본 메서드를 사용하기 위해서 우회를 해야한다는 점이 있다.

### **② 프로토타입 체인**

![https://blog.kakaocdn.net/dn/2jzBA/btrnktG1jOY/Q6yhgyIoYMLz0fP55S2mR0/img.jpg](https://blog.kakaocdn.net/dn/2jzBA/btrnktG1jOY/Q6yhgyIoYMLz0fP55S2mR0/img.jpg)

**proto**는 생략 가능하기 때문에 배열이 array.prototype 내부의 메서드를 마치 자신의 것처럼 실행할 수 있다. 마찬가지로 object.prototype 내부의 메서드도 자신의 것처럼 실행할 수 있다. 생략 가능한 **proto**를 한 번 더 따라가면 object.prototype을 참조할 수 있기 때문

**프로토타입 체인 _prototype chain_** : 어떤 데이터의 **proto** 프로퍼티 내부에서 다시 **proto** 프로퍼티가 연쇄적으로 이어진 것

**프로토타입 체이닝 _prototype chianing_** :  프로토타입 체인을 따라가며 검색하는 것 (메서드 오버라이드와 동일한 맥락)

```jsx
var arr = [1, 2];
Array.prototype.toString.call(arr); //1,2
Object.prototype.toString.call(arr); //[object Array]
arr.toString(); //1,2

arr.toString = function () {
  return this.join("_");
};
arr.toString(); //1_2
```

arr 변수는 배열이므로 `arr.__proto__`는 Array.prototype을 참조하고, Array.prototype은 객체이므로 `Array.prototype.__proto__`는 Object.prototype을 참조합니다.

배열뿐만 아니라 자바스크립트의 모든 데이터가 프로토타입 체인 구조를 가짐

### 객체 전용 메서드의 예외사항

**어떤 생성자 함수이든 prototype은 반드시 객체이기 때문에 object.prototype이 언제나 프로토타입 체인의 최상단에 존재**하게 된다. 따라서 객체에서만 사용할 메서드는 다른 여느 데이터 타입처럼 프로토타입 객체안에 정의할 수 없다. 객체에서만 사용할 메서드를 object.prototype 내부에 정의한다면 다른 데이터 타입도 해당 메서드를 사용할 수 있게 되기 때문.

### 다중 프로토타입 체인

다중 프로토타입 체인을 연결하는 방법은 **proto**가 가리키는 대상, 즉 생성자 함수의 prototype이 연결하고자 하는 상위 생성자 함수의 인스턴스를 바라보게끔 해주면 된다.

## 질문

this를 사용한 예시를 prototype을 사용하여 코드를 변경해보고 이로서 오는 장점을 적어주세요.

```jsx
function Toy(name) {
  this.name = name;
  this.battery = 100;
  this.charge = function () {
    battery += 10;
    console.log(`charging is finished. battery is ${this.battery}`);
  };
}

const woody = new Toy("woody");
const buzz = new Toy("buzz");
```
