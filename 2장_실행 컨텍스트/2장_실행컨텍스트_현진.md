# 2장: 실행 컨텍스트(요약)

## 실행 컨텍스트란?

*그래서 정의된 데이터, 변수들은 어떻게 실행되나?*

: 실행할 코드에 제공할 환경 정보들을 모아놓은 객체

### 환경 정보

1. 변수: 전역 변수, 지역 변수, 매개 변수, 객체의 프로필
2. 함수 선언
3. 변수의 유효 범위
4. this

- 실행 컨텍스트들은 **콜 스택**에 쌓인다

```jsx
//책의 예제

var x = 'xxx';

function foo () {
  var y = 'yyy';

  function bar () {
    var z = 'zzz';
    console.log(x + y + z);
  }
  
  bar();
}

foo();
```

![Untitled](2%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%20%E1%84%8F%E1%85%A5%E1%86%AB%E1%84%90%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3(%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8)%206b71bfa4f3ce48288f32a6186c1d39bd/Untitled.png)

                                                           스택이니까 맨 위에서 부터 실행된다

### 사전 지식

**콜 스택(call statck)?** 
: 호출스택(call stack)은 여러 함수들을 호출하는 스크립트에서 해당 위치를 추적하는 **interpreter**를 위한 메커니즘 (- MDN) 
= 함수 호출을 기록하는 스택 자료구조

인터프리터 언어 vs 컴파일 언어

|  | 인터프리터 언어 | 컴파일 언어 |
| --- | --- | --- |
| 종류 | 자바스크립트 언어 | C, java |
|  | 컴파일 과정이 따로 없고, 실행시 평가가 일어남 |  |
- 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드를 실행함으로서, 전체 코드의 환경과 순서를 보장한다.

⇒ 코드를 보고 어떤 순서로 쌓이고, 어떤 순서로 실행되는지 알 수 있어야 한다

## 실행 컨텍스트의 종류(언제 생성되는데?)

1. **전역공간(Global Execution context)**

- 처음 코드를 실행할 떄 단 한번 **Global Execution Context**를 생성
    - window 전역 컨텍스트를 생성합니다.
    - this 를 전역 객체(Global Object)로 설정합니다.

**2. eval() 함수: 위험하기 때문에 쓰지 않는 것을 권장하고 있다**

- eval 함수란
    
    : •문자로 표현 된 JavaScript 코드를 실행하는 함수
    
    ```jsx
    //ex.
    console.log(eval('2 + 2'));
    // expected output: 4
    
    console.log(eval(new String('
    ```
    
    문제
    1) 외부 변수를 변경 할 수 있다
    
    ```jsx
    let x = 5;
    eval("x = 10");
    alert(x); // 10, 변경된 값
    ```
    
    2) 자체적인 렉시컬 환경을 가지고 있다
    
    ```jsx
    let a = 1;
    
    function f() {
      let a = 2;
    
      eval('alert(a)'); // 2
    }
    
    f();
    ```
    

**3. 함수가 실행될 때** 

- 가장 흔하게 실행 컨텍스트를 구성하는 방법
- 함수를 호출할 때 마다 함수를 위한 **Execution context**를 생성

## 실행 컨텍스트 생성 로직(구성)

: 실행 컨텍스트는 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념이지만 물리적으로는 객체의 형태를 가지며 아래의 3가지 프로퍼티를 소유한다.

![Untitled](2%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%20%E1%84%8F%E1%85%A5%E1%86%AB%E1%84%90%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3(%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8)%206b71bfa4f3ce48288f32a6186c1d39bd/Untitled%201.png)

![Untitled](2%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%20%E1%84%8F%E1%85%A5%E1%86%AB%E1%84%90%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3(%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8)%206b71bfa4f3ce48288f32a6186c1d39bd/Untitled%202.png)

### 1. **Variable Environment**

: 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보. 선언 시점의 LexicalEnvironment의 스냅샷으로, 변경사항은 반영되지 않음

- environmentRecord
- outer-EnvironmentReference

### 2. **Lexical Environment**

: 처음에는 VariableEnvironment와 같지만 변경사항이 실시간으로 반영됨

- environmentRecord
- outer-EnvironmentReference
- **ThisBinding** : this 식별자가 바라보고 있는 대상 객체

### **VariableEnvironment와 LexicalEnvironment의 차이점**

**VariableEnvironment**

- var로 선언된 변수가 메모리에 매핑되고 초기값으로 undefined가 할당됩니다. var로 선언한 변수를 위한 Function scope를 단위로 합니다.

**LexicalEnvironment**

- let, const로 선언된 변수가 메모리에 매핑되고 초기값은 할당되지 않습니다. 함수 선언이 메모리에 매핑되고 함수 전체가 할당됩니다. let과 const로 선언한 변수를 위한 Block scope를 단위로 합니다.
- [ECMA-262 6th](https://262.ecma-international.org/6.0/#sec-lexical-environments)에서는 "Usually a Lexical Environment is associated with some specific syntactic structure of ECMAScript code such as a *FunctionDeclaration*, a *BlockStatement*, or a *Catch* clause of a *TryStatement* and a new Lexical Environment is created each time such code is evaluated." 라고 하고 있습니다. 즉, 함수 선언, { } 블록문, try/catch문 같은 코드가 실행될 때마다 새로운 LexicalEnivronment가 생기게 됩니다.
