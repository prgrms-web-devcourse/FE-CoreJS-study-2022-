# 클로저란?

- 클로저는 자바스크립트 고유의 개념이 아니라 여러 함수형 프로그래밍 언어에서 등장하는 보편적인 특성
- **함수와 그 함수가 선언될 당시의 Lexical Environment(outerEnvironmentReference)의 상호관계에 따른 현상**
- 클로저는 어떤 함수에서 선언한 변수를 **참조하는 내부함수**에서만 발생하는 현상

```jsx
// Case 1
var outer = function () {
  var a = 1;
  var inner = function () {
    console.log(++a)
  }
  inner();
}
outer(); // 2

// Case 2
var outer = function () {
  var a = 1;
  var inner = function () {
    return ++a;
  }
  return inner(); // inner 함수의 실행 결과를 반환하고 있다
}
var outer2 = outer();
console.log(outer2);  // 2
```

1. inner 함수 내부에서는 a를 따로 선언하지 않았기 때문에 `environmentRecord`에서 값을 찾지 못하므로 `outerEnvironmentReference`에 지정된 상위 컨텍스트인 **outer의 `LexicalEnvironment`에 접근**해서 a를 찾게 됩니다.
2. **outer 함수의 실행 컨텍스트가 종료되면** LexicalEnvironment에 저장된 식별자들(a, inner)에 대한 참조를 지웁니다.
3. 그러면 각 주소에 저장되어 있던 값들은 자신을 참조하는 변수가 하나도 없게 되므로 가비지 컬렉터의 수집 대상이 됩니다

### ⇒ Q. 그렇다면 outer의 실행 컨텍스트가 종료된 이후에도 inner 함수 자체를 호출할 수 있는 방법이 없을까?

### A. inner 함수의 실행 결과가 아닌 inner 함수 자체를 반환

: **지역변수를 참조하는 내부함수가 외부로 전달된 경우(여기서는 inner함수),** 함수의 실행 컨텍스트가 종료된 후에도LexicalEnvironment가 가비지 컬렉터의 수집 대상에서 제외된다

```jsx
var outer = function () {
  var a = 1;
  var inner = function () {
    return ++a;
  }
  return inner; // inner 함수 자체를 반환
};
var outer2 = outer();
console.log(outer2()); // 2
console.log(outer2()); // 3
```

<aside>
🍀 클로저란 <br>
어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 
A의 실행 컨텍스트가 종료된 후에도 참조한 변수 a가 사라지지 않는 현상
</aside><br>

# 클로저 활용

### 1. 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때

방법 1. 콜백 함수를 내부함수로 선언해서 외부변수를 직접 참조하는 방법

방법 2. bind 메서드로 값을 직접 넘겨주는 방법

방법 3. 콜백 함수를 고차함수로 바꿔서 클로저를 활용한 방법

고차함수란?

함수를 인자로 받거나 함수를 리턴하는 함수이다.

### 2. 접근 권한 제어 (정보 은닉)

자바스크립트는 변수 자체에 접근 권한 (public, private, protected) 을 직접 부여하도록 설계돼 있지 않다.

클로저를 이용하여 public 한 변수와 private 한 값을 구분할 수 있다.

```jsx
var createCar =function () {
var fuel =Math.ceil(Math.random() * 10 + 10);
var moved = 0;
return {
getmoved() {
return moved;
        },

        run:function () {
var km =Math.ceil(Math.random() * 6);
var wasteFuel = km / 10;
            fuel -= wasteFuel;
            moved += km;
            console.log(km + "km 이동 , 남은 연료 : " + fuel);
        }
    };
};
var car =createCar();

car.run();// 3km 이동 , 남은 연료 17.3console.log(car.moved);// 3console.log(car.fuel);// undefined

car.fuel = 1000;
console.log(car.fuel);// 1000
car.run();// 1km 이동, 남은 연료 17

car.moved = 1000;
console.log(car.moved);// 4
```

1. (car.moved) 가 출력되는 이유는 getMethod 때문

2. car.fuel = 1000; 이라는 의미는 car 객체에 새로운 fuel 이라는 프로퍼티를 추가하는 행위를 하는 것이다. 따라서 createCar() 내부에 실제 fuel 이라는 변수에는 접근 하는 것이라고는 볼 수 없다.

<br>
### 3. 부분 적용 함수

부분 적용 함수 : n 개의 인자를 받는 함수에 미리 m개의 인자만 넘겨 기억시켰다가, 나중에 (n-m) 개의 인자를 넘기면 비로소 원래 함수의 실행 결과를 얻을 수 있게끔 하는 함수입니다.

미리 일부 인자를 넘겨두어 기억하게끔 하고, 추후 필요한 시점에 기억했던 인자들까지 함께 실행하게 한다는 개념 자체가 클로저의 정의에 정확히 부합한다.
<br>

### 4. 커링 함수

커링 함수 : 여러 개의 인자를 받는 함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출될 수 있게 체인 형태로 구성한 함수 이다.

커링은 한 번에 하나의 인자만 전달하는 것을 원칙으로 합니다.

마지막 인자가 전달되기 전까지는 원본 함수가 실행되지 않습니다.

> 부분 적용 함수와 커링 함수의 차이점
> 

```jsx
var curry3 =function (func) {
returnfunction (a) {
returnfunction (b) {
returnfunc(a,b);
        };
    };
};

var getMaxWith10 =curry3(Math.max)(10);
console.log(getMaxWith10(8));// 10console.log(getMaxWith10(25));// 25
```

# 🎁퀴즈

```jsx
(function immediateA(a) {
  return (function immediateB(b) {
    console.log(a); // What is logged?
  })(1);
})(0);
```