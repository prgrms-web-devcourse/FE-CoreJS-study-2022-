# 클래스
## 1. 클래스와 인스턴스의 개념
- class : 사전적으로 `계급, 집단, 집합`의 의미를 가짐, 특정한 속성을 지닌 집합이라고 보면됨
- instance : class의 속성을 지니고 있는 개체

### 클래스 간의 상하관계

![image](https://user-images.githubusercontent.com/15838144/179955050-73764d7c-8a5d-4490-b737-5c0ceadf8730.png)

- 음식은 과일의 superclass
- 과일은 음식의 subclass, 귤류의 superclass
- 귤류는 과일의 subclass

## 2. 자바스크립트의 클래스
### static method, prototype method 예시
```js
// 생성자
const Rectangle = function (width, height) {
  this.width = width;
  this.height = height;
};

// prototype method
Rectangle.prototype.getArea = function () {
  return this.width * this.height;
};

// static method
Rectangle.isRectangle = function (instance) {
  return instance instanceof Rectangle && instance.width > 0 && instance.height > 0;
};

const rect1 = new Rectangle(3, 4);
console.log(rect1.getArea());  // 12
console.log(Rectangle.isRectangle(rect1));  // true
console.log(rect1.isRectangle(rect1));  // error
```

- 프로토타입 객체에 할당한 메서드는 인스턴스가 마치 자신의 것처럼 호출할 수 있음
- 따라서 rect1.getArea()는 Rectangle.prototype.getArea을 실행시킴 
- 이처럼 인스턴스에서 직접 호출할 수 있는 메서드가 `프로토타입 메서드`라 불립

- 이와 다르게 rect1.isRectangle(rect1)은 접근이 불가능하여 에러를 발생시킴
- 이처럼 인스턴스에서 직접 접근할 수 없는 메서드가 `스태틱 메서드`라 불림
- 스태틱 메서드는 Rectangle.isRectangle(rect1)처럼 생성자 함수를 this로 지정해야만 호출할 수 있음

## 3. 클래스 상속
### 다중 프로토타입 체인으로 클래스 상속 구현
```js
// Grade 생성자 함수 및 인스턴스
const Grade = function () {
  const args = Array.prototype.slice.call(arguments);
  for (let i = 0; i < args.length; i++) {
    this[i] = args[i];
  }
  this.length = args.length;
};

Grade.prototype = [];
const g = new Grade(100, 80);
```
> 클래스 상속과 프로토타입 체인의 관계
![image](https://user-images.githubusercontent.com/15838144/179958260-78ed09ea-c602-4365-9ec0-73e0f6a561e7.png)

- 세부적으로 완벽하게 superclass와 subclass의 구현이 안 이루어짐
- 예를 들어 length 프로퍼티가 삭제 가능하다는 점과, Grade.prototype에 빈 배열을 참조시켰다는 점이 큰 문제

### length 프로퍼티를 삭제한 경우
```js
// Grade 생성자 함수 및 인스턴스
const Grade = function () {
  const args = Array.prototype.slice.call(arguments);
  for (let i = 0; i < args.length; i++) {
    this[i] = args[i];
  }
  this.length = args.length;
};

Grade.prototype = [];
const g = new Grade(100, 80);
g.push(90);
console.log(g);  
/* Array {
  '0': 100,
  '1': 80,
  '2': 90,
  length: 3,
  __proto__: { length: 3 }
} */

delete g.length;
g.push(70);
console.log(g);
/* Array {
  '0': 70,
  '1': 80,
  '2': 90,
  length: 1,
  __proto__: { length: 1 }
} */
```

- length 프로퍼티를 삭제하고 push를 하면 push한 값이 0번째 인덱스에 들어가고 length는 1로 변경됨
- 내장객체인 배열 인스턴스의 length 프로퍼티는 configurable 속성이 false라서 삭제가 불가능한 반면, Grade 클래스의 인스턴스는 배열 메서드를 상속하지만 기본적으로 일반 객체의 성질을 그대로 지니므로 삭제가 가능해서 문제가됨

## 4. ES6의 클래스 및 클래스 상속
### ES6 이전 클래스 개념 구현 방식
```js
var ES5 = function(name) {
  console.log(name)  // 'es5'
  this.name = name;
};

ES5.staticMethod = function () {
  console.log(this.name)  // 'ES5'
  return this.name + ' staticMethod';
};

ES5.prototype.method = function () {
  return this.name + ' method';
};

var es5Instance = new ES5('es5');
console.log(ES5.staticMethod());  // 'ES5 staticMethod'
console.log(es5Instance.method());  // 'es5 method'
```

### ES6 이후 클래스 개념 구현 방식
```js
const ES6 = class {
  constuctor (name) {
    this.name = name;
  } 
  
  static staticMethod () {
    console.log(this.name);  // 'ES6'
    return this.name + ' staticMethod';
  }
  
  method () {
    console.log(this.name);  // undefined
    return this.name + ' method';
  }
};

const es6Instance = new ES6('es6');
console.log(ES6.staticMethod());  // 'ES6 staticMethod'
console.log(es6Instance.method());  // 'undefined method'
```

- ES6의 constructor는 ES5에서의 생성자 함수와 동일한 역할을 수행
- static 키워드는 해당 메서드가 static 메서드임을 알리는 내용으로, 생성자 함수(클래스) 자신만이 호출할 수 있음
- ES6의 method는 자동으로 prototype 객체 내부에 할당되는 메서드(인스턴스가 프로토타입 체이닝을 통해 마치 자신의 것처럼 호출할 수 있음)

### ES6의 클래스 상속
```js
const Rectangle = class {
  constructor (width, height) {
    this.width = width;
    this.height = height;
  }
  
  getArea () {
    return this.width * this.height;
  }
};

const Square = class extends Rectangle {
  constructor (width) {
    super (width, width);
  }
  
 getArea () {
    console.log('Size is : ' + super.getArea());
  } 
};

const square = new Square(5);
square.getArea();  // 'Size is : 25'
```

- Square를 Rectangle 클래스를 상속받는 하위클래스로 만들기 위해 class 명령어 뒤에 단순히 `extends Rectagle`이라는 내용을 추가하여 상속 관계를 설정
- 하위 클래스 내부에서 super 키워드는 함수처럼 사용되며, super는 Superclass의 constuctor를 실행
- constructor를 제외한 다른 메서드에서는 super 키워드를 마치 객체처럼 사용할 수 있음
- 이때 super는 SuperClass.prototype을 바라보는데, 호출한 메서드의 this는 `super`가 아닌 원래(SuperClass)의 this를 그대로 가리킴


# Quiz