## 1. 클래스와 인스턴스의 개념 이해

- 현실 클래스와 비교
    - 공통점: 무언가를 분류, 속하는 하위 개념이 있다
    - 차이점: 하위→ 상위를 정의하는 현실과 다르게, 상위가 정해져야 하위 인스턴스를 생성할 수 있다
    

## 2. 자바스크립트의 클래스

- 자바스크립트는 클래스의 개념이 존재하지 않는다. 그렇지만 프로토타입을 일반적인 의미에서의 클래스 관점에서 접근해보면 비슷하게 해석할 수도 있다
- 프로토타입 메서드: 인스턴스에서 직접 호출할 수 있는 메서드
- 스태틱 매서드: 인스턴스에서 직접 접근할 수 없고, this로만 접근할 수 있는 메서드
(`Object.prototype`까지 타고 올라가서 없으니 TypeError,
`생성자함수.스태틱메서드(인스턴스)`로 생성자 함수 호출하면 사용 가능)

예시

```jsx
// 생성자 
var Rectangle = function (width, height) {
  this.width = width;
  this.height = height;
};

// (프로토타입) 메서드
Rectangle.prototype.getArea = function() {
  return this.width * this.height;
};

// 스태틱 메서드
Rectangle.isRectangle = function(instance) {
  return instance instanceof Rectangle &&
  	instance.width > 0 && instance.height > 0;
};

var rect1 = new Rectangle(3,4);

console.log(rect1.getArea()); //12 : 호출가능
console.log(rect1.isRectangle());// Error: rect1.isRectangle is not a function
console.log(Rectangle.isRectangle(rect1));// true
```

## 3. 클래스 상속

- 자바스크립트에는 클래스 상속이 없지만, 프로토 체인을 활용해 객체지향 클래스를 따라하는 문법이 있다
- 하위 클래스로 삼을 생성자 함수의 prototype에 상위 클래스의 인스턴스를 부여하기
    - 기본적인 메서드 상속 가능
    - 하지만 상속받은 메서드가 configurable하고 상위 클래스로 활용할 인스턴스에 이미 존재하는 값이 문제가 됨

### ****클래스가 구체적인 데이터를 지니지 않게 하는 법****

---

1. 프로퍼티들을 일일이 지우고 더는 새로운 프로퍼티를 추가할 수 없게 함

2. 빈 함수(Bridge)를 활용하는 방법
- Subclass의 prototype에 직접 Superclass의 인스턴스를 할당하는 대신 아무런 프로퍼티를 생성하지 않는 빈 생성자 함수(Bridge)를 하나 더 만들어서 그 prototype을 바라보게 한 다음, SubClass의 prototype에는 Bridge의 인스턴스를 할당하게 함

```jsx
  var Rectangle = function(width, height){
         this.width = width;
         this.height = height;
     }

     Rectangle.prototype.getArea = function(){
         return this.width * this height;
     }

     var Square = function(width) {
         Rectangle.call(this, width, width);
     }

     var Bridge = function () {};
     Bridge.prototype = Rectangle.prototype;
     Square.prototype = new Bridge();
     Object.freeze(Square.prototype);
```

1. Object.create를 이용하는 방법

```jsx
Square.prototype = Object.create(Rectangle.prototype);
Object.freeze(Square.prototype);
```

⇒ 세 방법 모두 subClass 인스턴스의 constructor가 여전히 SuperClass를 가리키고 있다.

SubClass.prototype.constructor가 원래 Subclass를 바라보도록 조정해야 한다.

## 4. ES5:  생성자 함수 + 프로토타입, ES6:  클래스

```jsx
// ES5
var ES5 = function (name) {
  this.name = name;
};

ES5.staticMethod = function () {
  return this.name + " 생성자 함수의 static method";
};

ES5.prototype.method = function () {
  return this.name + " prototype method";
};

var inst = new ES5("ES5 인스턴스");
console.log(ES5.staticMethod()); // ES5 생성자 함수의 static method
console.log(inst.staticMethod()); // Error
console.log(inst.method()); // ES5 인스턴스 prototype method

```

```jsx
// ES6
var ES6 = class {
  constructor(name) {
    this.name = name;
  }

  static staticMethod() {
    return this.name + " 클래스의 static method";
  }

  method() {
    return this.name + " method(prototype method)";
  }
};

var inst = new ES6("ES6 인스턴스");
console.log(ES6.staticMethod()); // ES6 클래스의 static method
console.log(inst.staticMethod()); // Error
console.log(inst.method()); // ES6 인스턴스 method(prototype method)
```

## 퀴즈
```jsx
console.log(Foo);
// 

class Foo {}
```

```jsx
const Foo = '';

{

  console.log(Foo);
  // 
  class Foo {}
}
```
