# 1장: 데이터 타입

## 1. 데이터 타입의 종류

- 기본형 (원시형): 값이 담긴 주솟값을 바로 복제
    - 숫자
    - 문자
    - 심볼 등
    
- 참조형: 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제
    - 객체
    - 배열
    - 맵

## 2. 메모리, 데이터에 대한 사전 지식

- 0과 1의 비트보다는 묶는게 여러 표현할 수 있고, 검색 시간이 줄어듬. → 1바이트(8비트) 탄생
- C나 자바는 메모리 낭비 최소화 위해 데이터 타입별로 메모리를 제한했다
- 자바스크립트는 숫자는 8바이트(정수, 소수 상관없이)로 좀더 넉넉하게 할당됐다.
문자는 제한 없음(왜냐하면 언어마다 필요가 다르기 때문)

## 3 ~ 4. 변수와 데이터

: 변수와 데이터 영역은 메모리가 따로 분리되어있다

1) 미리 확보된 공간 내에서만 데이터 변환을 할 수 있으면 필요 연산이 많아짐

2) 나중에 변수가 많아지면 중복값은 같은 데이터 주소처리를 해줄 수 있어서, 중복 데이터 처리 효율이 높아져서

(중복값이 많아질 경우를 대비한 효율적 구조)

- 기본형 데이터 = 불변값
    - 숫자 ,문자열, boolean, null, undefined, Symbol
    - 데이터 영역이 바뀌지 않는다

![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%206a648bd11a1d4049a90e2cdd00992b06/Untitled.png)

- 참조형 데이터 (거의 가변값)
    - 객체의 변수(프로퍼티)의 영역이 별도로 존재
    - 변수에는 다른 값을 계속 대입할 수 있다

**참조형 데이터 할당**

```jsx
let obj1 = {
  a: 1,
  b: 'bbb'
}
```

![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%206a648bd11a1d4049a90e2cdd00992b06/Untitled%201.png)

**재할당**

```jsx
var obj1 = {
	a : 1,
  b : 'bbb'
};
obj1.a = 2; 
// obj1의 a의 프로퍼티를 재 할당 해보자.
```

![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%206a648bd11a1d4049a90e2cdd00992b06/Untitled%202.png)

**가변값 중첩 된 참조형 데이터(객체)의 프로퍼티 할당**

```jsx
let obj = {
  x: 3,
  arr: [ 3, 4, 5]
};
obj.arr = 'str';
```

![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%206a648bd11a1d4049a90e2cdd00992b06/Untitled%203.png)

### 5. 기본형 데이터 vs 참조형 데이터(변수 복사)

1. **변수 복사 시**

```jsx
var a = 10;
var b = a;

var obj1 = {c: 10, d: 'ddd'}
var obj2 = obj1
```

![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%206a648bd11a1d4049a90e2cdd00992b06/Untitled%204.png)

- 기본형 데이터: 변수 영역에 빈 공간을 확보하고 주소를 넣는다
- 참조형 데이터: 위와 같음

1. **변수 복사 이후, 객체 프로퍼티 변경**

```jsx
var a = 10;
var b = a;

var obj1 = {c: 10, d: 'ddd'}
var obj2 = obj1

b= 15;
obj2.c = 20
```

![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%206a648bd11a1d4049a90e2cdd00992b06/Untitled%205.png)

- 기본형 데이터: 값이 달라짐
- 참조형 데이터: 값이 달라지지 않음
    
    ⇒ 동시 변경의 위험성이 있다
    
1. **변수 복사 이후, 객체 자체 변경**

```jsx
var a = 10;
var b = a;

var obj1 = {c: 10, d: 'ddd'}
var obj2 = obj1

b= 15;
obj2 = {c: 20, d: 'fff' }
```

![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%206a648bd11a1d4049a90e2cdd00992b06/Untitled%206.png)

- 기본형 데이터: 값이 달라짐
- 참조형 데이터: 값이 달라짐

## 6. 불변 객체

- 객체 가변성의 문제점
: 위에 5-2번처럼, 원본 객체가 변경되는 문제가 생긴다.

**해결법**

1) 얕은 복사

: 바로 아래 단계의 값만 복사하는 방법, 주솟값만 복사

```jsx
var copyObject = function (target) {
	var result = {};
	for (var prop in target) {
		result[prop] = target[prop];
	}
	return result;
}
```

→ 사본을 바꾸면 원본이 바뀐다 (같은 주소값을 참고하고 있기 때문)

2) 깊은 복사

: 모든 값들을 하나씩 찾아서 전부 복사 

```jsx
var copyObjectDeep = function(target) {
	var result = {};
	if(typeof target === 'object' && target !== null) {
		for (var prop in target) {
			result[prop] = copyObjectDeep(target[prop])
		}
	} else {
		result = target;
	}
	return result;
}
```

- JSON.parse(JSON.stringify) 활용한 깊은 복사

## 7. undefined & null: 없음을 나타낼 때

### undefined

: 어떤 변수에 값이 존재하지 않는 경우

- 값이 존재하지 않을 때 자바스크립트 엔진에서 자동으로 부여
- 그 자체가 값이다. 배열에서 길이를 순회할 때 길이 값으로 포함한다(순회의 대상이 됨)

### null

: 비어있음을 명시적으로 나타내고 싶을 때 

- typeof null = object이다 
→ 동등 연산자(==)로 비교했을 때는 null과 undefined가 서로 같다고 판단
→ 일치 연산자로 비교해야 함